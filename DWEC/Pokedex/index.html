<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Batalla Pokémon</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <style>
    /* (Estilos iguales a los originales) */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 20px;
      min-height: 90vh;
    }
    .mode-select {
      text-align: center;
      padding: 40px;
      background: #fff;
      border-radius: 15px;
      max-width: 400px;
      margin: 100px auto;
    }
    .mode-select select {
      width: 100%;
      padding: 10px;
      margin: 20px 0;
      font-family: 'Press Start 2P', cursive;
    }
    .game-board {
      display: flex;
      gap: 20px;
      height: 100%;
    }
    .player-section {
      width: 250px;
      padding: 20px;
      background: #f5f5f5;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .cards {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .card {
      background: white;
      border: 2px solid #ffd700;
      border-radius: 10px;
      padding: 10px;
      cursor: grab;
      display: flex;
      align-items: center;
      gap: 10px;
      transition: all 0.2s;
    }
    .card:hover {
      transform: translateX(5px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .card.dead {
      opacity: 0.5;
      border-color: red;
    }
    .card img {
      width: 60px;
      height: 60px;
      object-fit: contain;
    }
    .card-info {
      flex: 1;
      text-align: left;
    }
    .card-name {
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .stats {
      font-size: 12px;
      color: #666;
    }
    .battle-zone {
      flex: 1;
      padding: 20px;
      background: #fff;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .battle-area {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 20px 0;
    }
    .battle-slot {
      width: 180px;
      height: 220px;
      border: 3px dashed #ff4444;
      border-radius: 15px;
      padding: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .battle-slot.filled {
      border-style: solid;
    }
    .battle-slot img {
      width: 100px;
      height: 100px;
      object-fit: contain;
    }
    .vs {
      font-size: 36px;
      font-weight: bold;
      color: #ffd700;
      font-family: 'Press Start 2P', cursive;
      margin: 0 20px;
    }
    .health-bar {
      width: 100%;
      height: 15px;
      background: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    .health-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #2ecc71, #27ae60);
      transition: width 0.3s;
    }
    .attacks {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 20px;
    }
    .attack-btn {
      background: #4a90e2;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
    }
    .attack-btn:hover {
      background: #357abd;
    }
    .btn {
      background: #4a90e2;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Press Start 2P', cursive;
    }
    .btn:hover {
      background: #357abd;
    }
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 15px;
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }
    .modal-buttons {
      position: sticky;
      bottom: 0;
      background: white;
      padding: 15px;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: center;
      gap: 10px;
      z-index: 2;
    }
    .pokemon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    .pokemon-option {
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
    }
    .pokemon-option.selected {
      border-color: #4a90e2;
      background: #f0f7ff;
    }
    .pokemon-option img {
      width: 80px;
      height: 80px;
      object-fit: contain;
    }
    .battle-message {
      font-family: 'Press Start 2P', cursive;
      font-size: 14px;
      color: #ff4444;
      margin: 10px 0;
      min-height: 20px;
    }
    h1, h2, h3 {
      font-family: 'Press Start 2P', cursive;
      color: #ff4444;
      margin-bottom: 15px;
    }
    @media (max-width: 1024px) {
      .game-board {
        flex-direction: column;
      }
      .player-section {
        width: 100%;
      }
      .cards {
        flex-direction: row;
        flex-wrap: wrap;
      }
      .card {
        width: calc(50% - 10px);
      }
    }
  </style>
</head>
<body>
  <div id="app" class="container">
    <!-- Selección de modo -->
    <div v-if="!mode" class="mode-select">
      <h1>BATALLA POKÉMON</h1>
      <select v-model="mode">
        <option disabled value="">Selecciona modo</option>
        <option value="pvp">Jugador vs Jugador</option>
        <option value="pve">Jugador vs Máquina</option>
      </select>
      <button @click="startSelection" class="btn">Comenzar</button>
    </div>

    <!-- Tablero de juego -->
    <div v-else class="game-board">
      <!-- Jugador 1 -->
      <div class="player-section">
        <h2>Jugador 1</h2>
        <div class="cards">
          <div v-for="(pokemon, index) in teamJ1" 
               :key="'J1-'+index" 
               class="card" 
               :class="{dead: pokemon.dead}"
               draggable="true"
               @dragstart="dragStart('J1', index, $event)">
            <img :src="pokemon.img" :alt="pokemon.name">
            <div class="card-info">
              <div class="card-name">{{ pokemon.name }}</div>
              <div class="stats">
                HP: {{ pokemon.hp }} | ATK: {{ pokemon.attack }}
              </div>
            </div>
          </div>
        </div>
        <button v-if="teamJ1.length < 5" class="btn" @click="openModal('J1')">
            Seleccionar Equipo
          </button>
          
      </div>

      <!-- Zona de batalla -->
      <div class="battle-zone">
        <div class="battle-message">{{ battleMessage }}</div>
        <div class="battle-area">
          <div class="battle-slot" 
               :class="{'filled': battleJ1}" 
               @dragover.prevent
               @drop="handleDrop('J1', $event)">
            <div v-if="battleJ1">
              <img :src="battleJ1.img" :alt="battleJ1.name">
              <div class="card-name">{{ battleJ1.name }}</div>
              <div class="health-bar">
                <div class="health-bar-fill" :style="{ width: (healthJ1 / battleJ1.hp * 100) + '%' }"></div>
              </div>
              <div>{{ healthJ1 }} / {{ battleJ1.hp }}</div>
            </div>
            <div v-else>
              <span>Arrastra Pokémon</span>
            </div>
          </div>

          <div class="vs">VS</div>

          <div class="battle-slot" 
               :class="{'filled': battleJ2}" 
               @dragover.prevent
               @drop="handleDrop('J2', $event)">
            <div v-if="battleJ2">
              <img :src="battleJ2.img" :alt="battleJ2.name">
              <div class="card-name">{{ battleJ2.name }}</div>
              <div class="health-bar">
                <div class="health-bar-fill" :style="{ width: (healthJ2 / battleJ2.hp * 100) + '%' }"></div>
              </div>
              <div>{{ healthJ2 }} / {{ battleJ2.hp }}</div>
            </div>
            <div v-else>
              <span>{{ mode === 'pvp' ? 'Arrastra Pokémon' : 'Pokémon Máquina' }}</span>
            </div>
          </div>
        </div>

        <div v-if="battleActive && !battleOver">
          <h3>Turno de {{ turn === 'J1' ? 'Jugador 1' : (mode === 'pvp' ? 'Jugador 2' : 'Máquina') }}</h3>
          <div class="attacks">
            <button v-for="move in currentMoves" 
                    :key="move.name"
                    class="attack-btn"
                    @click="attack(move)">
              {{ move.name }} ({{ move.power }})
            </button>
          </div>
        </div>
      </div>

      <!-- Jugador 2 / Máquina -->
      <div class="player-section">
        <h2>{{ mode === 'pvp' ? 'Jugador 2' : 'Máquina' }}</h2>
        <div class="cards">
          <div v-for="(pokemon, index) in teamJ2" 
               :key="'J2-'+index" 
               class="card" 
               :class="{dead: pokemon.dead}"
               draggable="true"
               @dragstart="dragStart('J2', index, $event)">
            <img :src="pokemon.img" :alt="pokemon.name">
            <div class="card-info">
              <div class="card-name">{{ pokemon.name }}</div>
              <div class="stats">
                HP: {{ pokemon.hp }} | ATK: {{ pokemon.attack }}
              </div>
            </div>
          </div>
        </div>
        <button v-if="mode === 'pvp' && teamJ2.length < 5" class="btn" @click="openModal('J2')">
            Seleccionar Equipo
          </button>
          
      </div>
    </div>

    <!-- Modal de selección -->
    <div class="modal" v-if="showModal">
      <div class="modal-content">
        <h2>Selecciona 5 Pokémon</h2>
        <button class="btn" @click="randomSelect">Aleatorio</button>
        <div class="pokemon-grid">
          <div v-for="pokemon in availablePokemon" 
               :key="pokemon.name"
               class="pokemon-option"
               :class="{selected: selected.some(p => p.name === pokemon.name)}"
               @click="toggleSelect(pokemon)">
            <img :src="pokemon.img" :alt="pokemon.name">
            <div>{{ pokemon.name }}</div>
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn" @click="confirmSelection" :disabled="selected.length !== 5">
            Confirmar ({{ selected.length }}/5)
          </button>
          <button class="btn" @click="closeModal">Cancelar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    async function getMoveDetails(moveUrl) {
      const response = await fetch(moveUrl);
      const moveData = await response.json();
      return {
        name: moveData.name.replace('-', ' '),
        power: moveData.power || 0,
        accuracy: moveData.accuracy || 100,
        type: moveData.type.name
      };
    }

    async function getRandomMoves(moves, count = 4) {
      let validMoves = [];
      const shuffled = [...moves].sort(() => 0.5 - Math.random());
      
      for (const move of shuffled) {
        if (validMoves.length >= count) break;
        const moveDetails = await getMoveDetails(move.move.url);
        if (moveDetails.power > 0) {
          validMoves.push(moveDetails);
        }
      }
      
      while (validMoves.length < count) {
        validMoves.push({ name: "Tackle", power: 40, accuracy: 100, type: "normal" });
      }
      
      return validMoves;
    }

    Vue.createApp({
      data() {
        return {
          mode: null,
          showModal: false,
          currentPlayer: null,
          selected: [],
          teamJ1: [],
          teamJ2: [],
          battleJ1: null,
          battleJ2: null,
          healthJ1: 0,
          healthJ2: 0,
          battleActive: false,
          turn: 'J1',
          battleOver: false,
          result: '',
          battleMessage: '',
          availablePokemon: [],
          allPokemon: [],
          typeChart: {
            fire: { strong: ['grass', 'ice', 'bug'], weak: ['water', 'rock', 'fire'] },
            water: { strong: ['fire', 'ground', 'rock'], weak: ['grass', 'electric', 'water'] },
            grass: { strong: ['water', 'ground', 'rock'], weak: ['fire', 'ice', 'poison'] },
            electric: { strong: ['water', 'flying'], weak: ['ground', 'grass', 'electric'] },
            ice: { strong: ['grass', 'ground', 'flying'], weak: ['fire', 'fighting', 'rock'] },
            fighting: { strong: ['normal', 'ice', 'rock'], weak: ['flying', 'psychic', 'fairy'] },
            poison: { strong: ['grass', 'fairy'], weak: ['ground', 'psychic'] },
            ground: { strong: ['fire', 'electric', 'poison'], weak: ['water', 'grass', 'ice'] },
            flying: { strong: ['grass', 'fighting', 'bug'], weak: ['electric', 'ice', 'rock'] },
            psychic: { strong: ['fighting', 'poison'], weak: ['bug', 'ghost', 'dark'] },
            bug: { strong: ['grass', 'psychic'], weak: ['fire', 'flying', 'rock'] },
            rock: { strong: ['fire', 'ice', 'flying'], weak: ['water', 'grass', 'fighting'] },
            ghost: { strong: ['psychic', 'ghost'], weak: ['dark', 'ghost'] },
            dragon: { strong: ['dragon'], weak: ['ice', 'dragon', 'fairy'] },
            dark: { strong: ['psychic', 'ghost'], weak: ['fighting', 'bug', 'fairy'] },
            steel: { strong: ['ice', 'rock'], weak: ['fire', 'fighting', 'ground'] },
            fairy: { strong: ['fighting', 'dragon', 'dark'], weak: ['poison', 'steel'] },
            normal: { strong: [], weak: ['fighting', 'ghost'] }
          }
        }
    },
      methods: {
        async fetchPokemon() {
          try {
            const response = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151");
            const data = await response.json();
            this.allPokemon = await Promise.all(data.results.map(async (pokemon) => {
              const res = await fetch(pokemon.url);
              const datos = await res.json();
              
              const moves = await getRandomMoves(datos.moves);
              
              return {
                name: datos.name,
                img: datos.sprites.other["official-artwork"].front_default || datos.sprites.front_default,
                hp: datos.stats[0].base_stat,
                attack: datos.stats[1].base_stat,
                defense: datos.stats[2].base_stat,
                moves: moves,
                dead: false,
                type: datos.types[0].type.name // Se agrega la propiedad "type"
              };
            }));
            this.availablePokemon = [...this.allPokemon];
          } catch (error) {
            console.error("Error fetching pokemon:", error);
            this.battleMessage = "Error cargando los Pokémon. Por favor, recarga la página.";
          }
        },
        startSelection() {
  if (this.mode === 'pve') {
    const checkPokemon = setInterval(() => {
      if (this.availablePokemon.length > 0) {
        clearInterval(checkPokemon);
        // Si el jugador aún no ha seleccionado su equipo, se auto-selecciona
        if (this.teamJ1.length < 5) {
          this.autoSelectTeam('J1');
        }
        // Seleccionamos 5 Pokémon aleatorios para la máquina
        const randomPokemon = [...this.availablePokemon]
          .sort(() => 0.5 - Math.random())
          .slice(0, 5);
        this.teamJ2 = randomPokemon;
        
        // Seleccionamos el primer Pokémon de cada equipo para la batalla
        this.battleJ1 = this.teamJ1[0];
        this.healthJ1 = this.battleJ1.hp;
        this.battleJ2 = this.teamJ2[0];
        this.healthJ2 = this.battleJ2.hp;
        
        // Inicia la batalla tras un breve retardo
        setTimeout(() => {
          this.startBattle();
        }, 500);
      }
    }, 100);
  }
},
        async attack(move) {
          if (this.battleOver) return;
          
          const attacker = this.turn === 'J1' ? this.battleJ1 : this.battleJ2;
          const defender = this.turn === 'J1' ? this.battleJ2 : this.battleJ1;
          
          // Verificar precisión
          if (Math.random() * 100 > move.accuracy) {
            this.showMessage(`¡${attacker.name} falló ${move.name}!`, 1500);
            this.passTurn();
            return;
          }

          // Calcular efectividad del tipo
          const effectiveness = this.calculateEffectiveness(move.type, defender.type);
          const stab = move.type === attacker.type ? 1.5 : 1;
          const critical = Math.random() < 0.1 ? 1.5 : 1;
          
          // Calcular daño
          const damage = this.calculateDamage(attacker, defender, move, effectiveness, stab, critical);
          
          // Aplicar daño
          if (this.turn === 'J1') {
            this.healthJ2 = Math.max(0, this.healthJ2 - damage);
          } else {
            this.healthJ1 = Math.max(0, this.healthJ1 - damage);
          }

          // Mostrar mensajes
          let message = `${attacker.name} usa ${move.name}!`;
          if (critical === 1.5) message += " ¡Golpe crítico!";
          if (effectiveness > 1) message += " ¡Es muy efectivo!";
          else if (effectiveness < 1) message += " No es muy efectivo...";
          this.showMessage(message, 1500);

          await this.checkBattleStatus();
          if (!this.battleOver) this.passTurn();
        },

        calculateEffectiveness(attackType, defenseType) {
          let effectiveness = 1;
          if (this.typeChart[attackType].strong.includes(defenseType)) effectiveness *= 2;
          if (this.typeChart[attackType].weak.includes(defenseType)) effectiveness *= 0.5;
          return effectiveness;
        },

        calculateDamage(attacker, defender, move, effectiveness, stab, critical) {
          const level = 50;
          const baseDamage = ((2 * level / 5 + 2) * move.power * attacker.attack / defender.defense) / 50 + 2;
          return Math.max(1, Math.floor(baseDamage * effectiveness * stab * critical * (0.85 + Math.random() * 0.15)));
        },

        passTurn() {
          this.turn = this.turn === 'J1' ? 'J2' : 'J1';
          if (this.mode === 'pve' && this.turn === 'J2') {
            setTimeout(() => this.aiTurn(), 1500);
          }
        },

        async checkBattleStatus() {
          if (this.healthJ1 <= 0 || this.healthJ2 <= 0) {
            const winner = this.healthJ1 > 0 ? 'J1' : 'J2';
            const loser = winner === 'J1' ? 'J2' : 'J1';
            
            // Marcar Pokémon como debilitado
            this[`team${loser}`].find(p => p.name === this[`battle${loser}`].name).dead = true;
            
            await this.showMessage(`¡${this[`battle${winner}`].name} gana la batalla!`, 2000);
            
            // Verificar si hay ganador final
            if (!this[`teamJ1`].some(p => !p.dead)) return this.endGame('J2');
            if (!this[`teamJ2`].some(p => !p.dead)) return this.endGame('J1');
            
            // Cambiar Pokémon automáticamente en PvE
            if (this.mode === 'pve' && loser === 'J2') {
              this.autoSelectNextPokemon('J2');
              await this.showMessage("¡La máquina está enviando otro Pokémon!", 1500);
              this.startBattle();
            } else {
              this.resetBattle();
            }
          }
        },

        autoSelectNextPokemon(player) {
          const alivePokemon = this[`team${player}`].filter(p => !p.dead);
          if (alivePokemon.length > 0) {
            this[`battle${player}`] = alivePokemon[0];
            this[`health${player}`] = this[`battle${player}`].hp;
          }
        },

        aiTurn() {
          const bestMove = this.selectBestMove();
          this.attack(bestMove);
        },

        selectBestMove() {
          const moves = this.battleJ2.moves;
          const effectiveMoves = moves.map(move => ({
            ...move,
            effectiveness: this.calculateEffectiveness(move.type, this.battleJ1.type)
          }));

          // Priorizar movimientos efectivos y de mayor poder
          return effectiveMoves.sort((a, b) => {
            if (a.effectiveness !== b.effectiveness) return b.effectiveness - a.effectiveness;
            return b.power - a.power;
          })[0];
        },

        showMessage(message, duration = 1500) {
          this.battleMessage = message;
          return new Promise(resolve => setTimeout(() => {
            this.battleMessage = '';
            resolve();
          }, duration));
        },
        autoSelectTeam(player) {
          const availablePokes = [...this.availablePokemon];
          const randomPokemon = [];
          for (let i = 0; i < 5 && availablePokes.length > 0; i++) {
            const randomIndex = Math.floor(Math.random() * availablePokes.length);
            randomPokemon.push(availablePokes.splice(randomIndex, 1)[0]);
          }
          if (player === 'J1') {
            this.teamJ1 = randomPokemon;
          } else {
            this.teamJ2 = randomPokemon;
          }
        },
        openModal(player) {
          this.currentPlayer = player;
          this.showModal = true;
          this.selected = player === 'J1' ? [...this.teamJ1] : [...this.teamJ2];
        },
        closeModal() {
          this.showModal = false;
          this.selected = [];
        },
        toggleSelect(pokemon) {
          const index = this.selected.findIndex(p => p.name === pokemon.name);
          if (index >= 0) {
            this.selected.splice(index, 1);
          } else if (this.selected.length < 5) {
            this.selected.push(pokemon);
          }
        },
        randomSelect() {
          this.selected = [];
          const availablePool = [...this.availablePokemon];
          while (this.selected.length < 5 && availablePool.length > 0) {
            const randomIndex = Math.floor(Math.random() * availablePool.length);
            this.selected.push(availablePool.splice(randomIndex, 1)[0]);
          }
        },
        confirmSelection() {
          if (this.selected.length === 5) {
            if (this.currentPlayer === 'J1') {
              this.teamJ1 = [...this.selected];
            } else {
              this.teamJ2 = [...this.selected];
            }
            this.closeModal();
          }
        },
        dragStart(player, index, event) {
          if (!this.battleActive) {
            const pokemon = player === 'J1' ? this.teamJ1[index] : this.teamJ2[index];
            if (!pokemon.dead) {
              event.dataTransfer.setData("application/json", JSON.stringify({ player, index }));
            }
          }
        },
        handleDrop(targetPlayer, event) {
  if (this.battleActive) return;
  
  const data = JSON.parse(event.dataTransfer.getData("application/json"));
  const { player, index } = data;
  
  if (player !== targetPlayer) return;
  
  const pokemon = player === 'J1' ? this.teamJ1[index] : this.teamJ2[index];
  if (pokemon.dead) return;
  
  if (targetPlayer === 'J1') {
    this.battleJ1 = pokemon;
    this.healthJ1 = pokemon.hp;
    if (this.battleJ2) this.startBattle();
  } else if (this.mode === 'pvp') {
    this.battleJ2 = pokemon;
    this.healthJ2 = pokemon.hp;
    if (this.battleJ1) this.startBattle();
  }
},
        startBattle() {
  // Verificar ambos Pokémon presentes
  if (!this.battleJ1 || !this.battleJ2) return;
  
  this.battleActive = true;
  this.turn = Math.random() < 0.5 ? 'J1' : 'J2';
  this.battleMessage = `¡Comienza la batalla entre ${this.battleJ1.name} y ${this.battleJ2.name}!`;

  // Manejar turno de IA inmediatamente
  if (this.mode === 'pve' && this.turn === 'J2') {
    this.aiTurn();
  }
},
        async attack(move) {
          if (this.battleOver) return;
          
          const attacker = this.turn === 'J1' ? this.battleJ1 : this.battleJ2;
          const defender = this.turn === 'J1' ? this.battleJ2 : this.battleJ1;
          
          // Verificar precisión
          const accuracyCheck = Math.random() * 100;
          if (accuracyCheck > move.accuracy) {
            this.battleMessage = `¡${attacker.name} falló el ataque!`;
            this.turn = this.turn === 'J1' ? 'J2' : 'J1';
            if (this.mode === 'pve' && this.turn === 'J2') {
              await new Promise(resolve => setTimeout(resolve, 1000));
              this.aiTurn();
            }
            return;
          }
          
          // Calcular daño (usando STAB si coincide el tipo)
          const stab = move.type === attacker.type ? 1.5 : 1;
          const randomFactor = 0.85 + (Math.random() * 0.15);
          const damage = Math.max(1, Math.floor(
            (((2 * 50 / 5 + 2) * move.power * attacker.attack / defender.defense) / 50 + 2) 
            * stab * randomFactor
          ));
          
          if (this.turn === 'J1') {
            this.healthJ2 = Math.max(0, this.healthJ2 - damage);
            this.battleMessage = `${attacker.name} usa ${move.name} y hace ${damage} de daño!`;
          } else {
            this.healthJ1 = Math.max(0, this.healthJ1 - damage);
            this.battleMessage = `${attacker.name} usa ${move.name} y hace ${damage} de daño!`;
          }
          
          await this.checkBattleStatus();
          
          if (!this.battleOver) {
            this.turn = this.turn === 'J1' ? 'J2' : 'J1';
            if (this.mode === 'pve' && this.turn === 'J2') {
              await new Promise(resolve => setTimeout(resolve, 1000));
              this.aiTurn();
            }
          }
        },
        aiTurn() {
          if (this.battleOver) return;
          const availableMoves = this.battleJ2.moves.filter(move => move.power > 0);
          const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
          this.attack(randomMove);
        },
        async checkBattleStatus() {
  if (this.healthJ1 <= 0 || this.healthJ2 <= 0) {
    this.battleOver = true;
    const winner = this.healthJ1 > 0 ? this.battleJ1 : this.battleJ2;
    const loser = this.healthJ1 > 0 ? this.battleJ2 : this.battleJ1;
    const loserPlayer = this.healthJ1 > 0 ? 'J2' : 'J1';

    // Marcar Pokémon derrotado
    if (this.healthJ1 <= 0) {
      this.battleJ1.dead = true;
      this.battleJ1 = null;
      this.healthJ1 = 0;
    } else {
      this.battleJ2.dead = true;
      this.battleJ2 = null;
      this.healthJ2 = 0;
    }

    this.result = `¡${winner.name} ha derrotado a ${loser.name}!`;
    this.battleMessage = this.result;

    await new Promise(resolve => setTimeout(resolve, 1500));

    // Verificar si hay ganador final
    const hasAliveJ1 = this.teamJ1.some(p => !p.dead);
    const hasAliveJ2 = this.teamJ2.some(p => !p.dead);
    if (!hasAliveJ1 || !hasAliveJ2) {
      this.battleMessage = `¡${hasAliveJ1 ? 'Jugador 1' : (this.mode === 'pvp' ? 'Jugador 2' : 'Máquina')} gana el juego!`;
      return;
    }

    // Preparar siguiente batalla
    this.battleOver = false;
    this.battleActive = false;

    // Manejar selección automática para IA
    if (this.mode === 'pve' && loserPlayer === 'J2') {
      const alivePokemon = this.teamJ2.filter(p => !p.dead);
      if (alivePokemon.length > 0) {
        const randomIndex = Math.floor(Math.random() * alivePokemon.length);
        this.battleJ2 = alivePokemon[randomIndex];
        this.healthJ2 = this.battleJ2.hp;
        this.startBattle();
      }
    }
  }
},
        closeBattle() {
          // Verificar si la partida ya terminó
          const hasAliveJ1 = this.teamJ1.some(p => !p.dead);
          const hasAliveJ2 = this.teamJ2.some(p => !p.dead);
          if (!hasAliveJ1 || !hasAliveJ2) {
            // Si algún equipo se quedó sin Pokémon vivos, se mantiene el mensaje final
            return;
          }
          
          // Reiniciamos el estado de batalla
          this.battleActive = false;
          this.battleJ1 = null;
          this.battleJ2 = null;
          this.battleOver = false;
          this.battleMessage = '';
          this.result = '';
          
          // En modo PvE, se selecciona automáticamente un nuevo Pokémon para la máquina
          if (this.mode === 'pve') {
            const alivePokemon = this.teamJ2.filter(p => !p.dead);
            if (alivePokemon.length > 0) {
              const randomIndex = Math.floor(Math.random() * alivePokemon.length);
              this.battleJ2 = alivePokemon[randomIndex];
              this.healthJ2 = this.battleJ2.hp;
            }
          }
        }
      },
      computed: {
        currentMoves() {
          const pokemon = this.turn === 'J1' ? this.battleJ1 : this.battleJ2;
          return pokemon ? pokemon.moves : [];
        }
      },
      mounted() {
        this.fetchPokemon();
      }
    }).mount('#app');
  </script>
</body>
</html>
